"""
    类的定义与使用：
        1. 类是基于关键字class来进行定义的。如果类之中没有任何内容，我们可以通过pass来实现。
        2. 类属性和方法：
            ①. 属性：其实就是变量。单独使用的叫做变量，而在类之中定义的叫做类的属性。
            ②. 方法：其实就是函数。单独封装的叫函数，在类中封装的叫做方法。
        在类中所定义的方法，默认都会存在self参数。self参数表示它自己。其实就是实例化对象。
        也就意味着，包含有self参数的为实例化方法。想要在外部调用这些方法必须通过实例化对象才可以。

        静态方法：就是不需要通过self即可实现调用。也就是不需要实例化，可以直接通过类名来调用的方法。
        类的属性无法通过实例化对象进行修改。

    类的调用：
        类中所有的属性和方法，默认都是基于实例化的行为来实现调用的。
        类的方法和属性，都是基于名称来实现调用。通过类名或者实例化对象的名称，加上.属性 或者 .方法()来实现。区别在于：属性调用不用在末尾加()，而方法需要。

    类的构造方法：
        每个类都有自己的默认的构造方法。可以定义，也可以不定义。
        构造方法是基于__init__(self)来定义的，每一个类之中只会存在一个构造方法

    类的作用域：
        类中所定义的所有属性和方法，都只在类之中有效，在类以外只能通过实例化对象或者自己来实现调用。否则无法使用。
"""
from tkinter.font import names


# 类的定义
class Person:
    # 属性
    name = "张三"
    age = 18
    sex = "男"

    # 构造方法
    def __init__(self, status):
        self.status = status    # 实例化时，定义一个status（当前状态）的属性

    # 方法
    def eat(self):
        print("吃吃吃吃吃")

    def drink(self):
        print("喝喝喝喝喝")

    def fun1(self):
        print(f"当前状态：{self.status}")    # 如果想要在类方法中调用类属性，则必须通过self.属性名称进行调用。
        print(self.name)
        self.eat()  # 如果想在方法中调用类自己的方法，则使用self.方法名()


    # 静态方法的定义
    @staticmethod   # @表示装饰器
    def show(): # 静态方法没有self参数。
        print("这是一个静态方法")



# # 类的实例化
# p1 = Person()   # 实例化对象，并赋值给到变量p1
# # 属性的调用
# print(p1.name)
# # 方法的调用
# p1.eat()
# p1.show()   # 静态方法的调用



# # 类自己的调用运行：也就是不进行实例化，直接调用。
# print(f"类属性的直接调用：{Person.name}")  # 类属性的直接调用
# # Person.eat()    # 报错：missing 1 required positional argument: 'self'。缺少一个必填的参数：self
# Person.show()   # 静态方法通过类名直接调用


# # 两个实例化对象
# Person().eat()
# Person().drink()
# # 一个实例化对象
# p2 = Person()
# p2.eat()
# p2.drink()


# ---------------------
# # 修改类中的属性的值
# # p1.name = "张三三" # 类的属性无法通过实例化对象进行修改；实例化对象只能修改自己的类属性
# print(p1.name)
# print(Person.name)
#
# Person.name = "张三三三"
# print(p1.name)


p1 = Person("还在找工作呢")   # 实例化需要遵循构造函数的规则来进行
p1.fun1()

