'''
XPath语法结构：
    XPath是基于元素的路径来进行元素定位的。所以也包含有【相对路径】和【绝对路径】的定位方式。
    相对路径（XPath）：推荐使用。例子如下：
        //*[@id="chat-textarea"]    从根路径下查找任意一个包含有id属性且属性值为"chat-textarea"的元素
        语法：
            //  从根路径下开始查找。也就是从HTML标签开始查找。
            *   表示任意元素（任意标签名称，div、a、span、input...）
            []  表示添加筛选条件。
            @   表示属性。（标签属性）
            id  表示id属性
            ="chat-textarea"    表示对于属性值

            text()  表示标签文本  例：//span[(text()="1")]

    绝对路径（完整XPath）：不推荐。（因为可维护性、可阅读性差）。但实在没办法时候可以使用。
        /html/body/div/div[3]/div[3]/div[1]/div/div[2]/div/div/div[1]/div/div[1]/div[4]/div[1]/div[2]/textarea

    XPath支持多条件关联查询，通过and关键字来实现多条件关联。也支持or的关联，但是不推荐使用。
    例：//input[@type="hidden" and @name="rsv_iqid"]

    XPath也包含有函数的运算
        contains：表示模糊查找，用于查找文本或者属性满足某个模糊条件
            //*[contains(@id,"b")]  查找任意元素，包含有id属性，且id属性值包含"b"字符串。
            //*[contains(text()="百")]   查找任意元素，包含有文本，且文本内容包含有"百"字符串


    通过复制获取的XPath会存在有不稳定，因为机器不会去重，其次遇到动态元素（每次加载页面的时候，某个属性会自动改变）也无法正常识别。
    推荐基于手写的形态会更加合适。
    通过路径推导来获取：从一个好获取定位的元素开始，（@id="g-topbar"）
        找下级：
            //div[@id="g-topbar"]/div[1]/div[3]/div[2]
        找上级：..
                //div[@id="g-topbar"]/..

    元素定位的小技巧：
        1. 如果目标元素不好定位，我们可以通过它的上级或者下级来进行定位，从而转向目标元素。
        2. XPath定位时，如果class属性值有很多。则不推荐使用class作为查询条件，因为可能会报错。
        3. 元素定位时，一定要确保你需要定位获取的元素的正确性。这个更多需要你自己的经验积累才可以。
        4. 元素定位的方法没有固定套路，合适的就是最好的。
'''